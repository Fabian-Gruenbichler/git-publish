#!/usr/bin/env python
#
# git-publish - Prepare and store patch revisions as git tags
#
# Copyright 2011 IBM, Corp.
#
# Authors:
#   Stefan Hajnoczi <stefanha@gmail.com>
#
# This work is licensed under the MIT License.  Please see the LICENSE file or
# http://opensource.org/licenses/MIT.

import os
import sys
import optparse
import re
import tempfile
import shutil
import subprocess

VERSION = '0.1+'

tag_version_re = re.compile(r'^[a-zA-Z0-9_\-]+-v(\d+)$')

# As a git alias it is helpful to be a single file script with no external
# dependencies, so these git command-line wrappers are used instead of
# python-git.

class NoCurrentBranchError(Exception):
    pass

def _git(*args):
    '''Run a git command and return a list of lines'''
    cmd = subprocess.Popen(['git'] + list(args), stdout=subprocess.PIPE)
    return cmd.communicate()[0].split(os.linesep)[:-1]

def git_get_current_branch():
    for line in _git('branch', '--no-color'):
        if '*' in line:
            return line.split()[1]
    raise NoCurrentBranchError

def git_get_tags(pattern=None):
    if pattern:
        return _git('tag', '-l', pattern)
    else:
        return _git('tag')

def git_get_tag_message(tag):
    message = []
    for line in _git('show', '--raw', '--no-color', tag)[4:]:
        if line.startswith('commit '):
            message.pop()
            return message
        message.append(line)
    return None

def git_log(revlist):
    return _git('log', '--no-color', '--oneline', revlist)

def git_tag(name, annotate=None):
    if annotate:
        _git('tag', '-a', '-F', annotate, name)
    else:
        _git('tag', '-a', '-m', '', name)

def git_format_patch(revlist, subject_prefix=None, output_directory=None,
                     numbered=False, cover_letter=False, signoff=False):
    args = ['format-patch']
    if subject_prefix:
        args += ['--subject-prefix', subject_prefix]
    if output_directory:
        args += ['--output-directory', output_directory]
    if numbered:
        args += ['--numbered']
    if cover_letter:
        args += ['--cover-letter']
    if signoff:
        args += ['--signoff']
    args += [revlist]
    _git(*args)

def git_send_email(to_list, cc_list, revlist_or_path, annotate):
    args = ['git', 'send-email']
    for address in to_list:
        args += ['--to', address]
    for address in cc_list:
        args += ['--cc', address]
    if annotate:
        args += ['--annotate']
    args += [revlist_or_path]
    subprocess.call(args)

def setup():
    '''Add git alias in ~/.gitconfig'''
    path = os.path.abspath(sys.argv[0])
    ret = subprocess.call(['git', 'config', '--global',
                           'alias.publish', '!' + path])
    if ret == 0:
        print 'You can now use \'git publish\' like a built-in git command.'

def tag_name(topic, number):
    '''Build a tag name from a topic name and version number'''
    return '%s-v%d' % (topic, number)

def pick_new_version(branch):
    '''Generate a patch version number given a branch name'''
    number = 0
    for tag in git_get_tags('%s-v[0-9]*' % branch):
        m = tag_version_re.match(tag)
        if not m:
            continue
        n = int(m.group(1))
        if n > number:
            number = n
    return number + 1

def get_number_of_commits(base):
    return len(git_log('%s..' % base))

def edit(filename):
    editor = 'vi'
    for envvar in 'VISUAL', 'EDITOR':
        if envvar in os.environ:
            editor = os.environ[envvar]
            break
    subprocess.call([editor, filename])

def tag(topic, number, annotate=False):
    template = None

    if annotate and number > 0:
        template = git_get_tag_message(tag_name(topic, number - 1))

    if not template:
        template = ['*** SUBJECT HERE ***', '', '*** BLURB HERE ***']

    fd, tmpfile = None, None

    try:
        if annotate:
            fd, tmpfile = tempfile.mkstemp(text=True)
            os.fdopen(fd, 'w').write(os.linesep.join(template + ['']))
            edit(tmpfile)

        git_tag(tag_name(topic, number), annotate=tmpfile)
    finally:
        if tmpfile:
            os.unlink(tmpfile)

def send_email(to_list, cc_list, topic, number, base, annotate, signoff):
    prefix = None
    if number > 1:
        prefix = 'PATCH v%d' % number

    numbered = get_number_of_commits(base) > 1
    message = git_get_tag_message(tag_name(topic, number))
    cover_letter = bool(message)
    revlist = '%s..' % base

    try:
        tmpdir = tempfile.mkdtemp()

        git_format_patch(revlist,
                         subject_prefix=prefix,
                         output_directory=tmpdir,
                         numbered=numbered,
                         cover_letter=cover_letter,
                         signoff=signoff)

        if message:
            cover_letter_path = os.path.join(tmpdir, '0000-cover-letter.patch')
            lines = open(cover_letter_path).readlines()
            lines = [s.replace('*** SUBJECT HERE ***', message[0]) for s in lines]
            blurb = os.linesep.join(message[2:])
            lines = [s.replace('*** BLURB HERE ***', blurb) for s in lines]
            open(cover_letter_path, 'w').writelines(lines)

        git_send_email(to_list, cc_list, tmpdir, annotate)
    finally:
        if tmpdir:
            shutil.rmtree(tmpdir)

def main():
    parser = optparse.OptionParser(version='%%prog %s' % VERSION,
            description='Prepare and store patch revisions as git tags.',
            epilog='Please report bugs to Stefan Hajnoczi <stefanha@gmail.com>.')
    parser.add_option('--annotate', dest='annotate', action='store_true',
                      default=False, help='review and edit each patch email')
    parser.add_option('-b', '--base', dest='base', default='master',
                      help='branch which this is based off [defaults to master]')
    parser.add_option('--cc', dest='cc', action='append', default=[],
                      help='specify a Cc: email recipient')
    parser.add_option('-n', '--number', type='int', dest='number', default=-1,
                      help='version number [auto-generated by default]')
    parser.add_option('--no-message', dest='message', action='store_false',
                      help='do not add a message')
    parser.add_option('-m', '--message', dest='message', action='store_true',
                      help='add a message')
    parser.add_option('--setup', dest='setup', action='store_true', default=False,
                      help='add git alias in ~/.gitconfig')
    parser.add_option('-t', '--topic', dest='topic',
                      help='topic name [defaults to current branch name]')
    parser.add_option('--to', dest='to', action='append', default=[],
                      help='specify a primary email recipient')
    parser.add_option('-s', '--signoff', dest='signoff', action='store_true',
                      default=False,
                      help='add Signed-off-by: <self> to commits when emailing')

    options, args = parser.parse_args()

    if options.setup:
        setup()
        return 0

    if options.topic:
        topic = options.topic
    else:
        topic = git_get_current_branch()
        if topic == 'master':
            print 'Please use a topic branch, cannot version master branch'
            return 1

    if options.number >= 0:
        number = options.number
    else:
        number = pick_new_version(topic)

    if options.message is None:
        # If there are several commits we probably want a cover letter
        message = get_number_of_commits(options.base) > 1
    else:
        message = options.message

    tag(topic, number, annotate=message)

    if options.to:
        send_email(options.to, options.cc, topic, number, options.base,
                   options.annotate)

    return 0

if __name__ == '__main__':
    sys.exit(main())
